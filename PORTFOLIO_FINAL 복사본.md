# 1~6 전체 재작성

---

## 1. 지역 해변 병렬 조회

### 30초 대기 문제

양양 지역의 평균 서핑 조건을 보여주려면 지역 내 10개 해변의 데이터가 필요했습니다. 각 해변을 순차적으로 조회하면 해변당 평균 3초, 총 30초가 걸렸습니다. 사용자가 대시보드에 진입할 때 30초를 기다려야 한다는 것은 받아들일 수 없었습니다.

### 원형 데이터의 평균

바람과 파도는 방향 정보를 가지고 있습니다. 북서풍 350도와 북동풍 10도의 평균을 구할 때, 일반적인 산술 평균(350+10)/2 = 180을 사용하면 남풍이 됩니다. 실제로는 북풍(0도) 근처여야 하는데 정반대 결과가 나옵니다. 방향은 0도와 360도가 연결된 원형 데이터이기 때문에 특수한 계산이 필요했습니다.

### RxSwift로 병렬 처리 구현

flatMapConcurrent 오퍼레이터로 10개 해변의 API 호출을 동시에 실행했습니다. maxConcurrent를 10으로 설정해 10개까지 동시 처리를 허용했습니다. 각 해변의 응답은 Single 스트림으로 방출되고, Single.zip으로 10개 응답을 하나의 배열로 결합했습니다. 모든 응답이 도착한 후에야 평균 계산이 시작됩니다.

이 방식으로 30초가 걸리던 작업이 3초로 단축되었습니다. 가장 느린 API 응답 시간만큼만 기다리면 되기 때문입니다.

### 삼각함수를 활용한 원형 평균

각 방향 값을 라디안으로 변환한 후, sin 값과 cos 값을 각각 계산했습니다. 예를 들어 350도는 sin(350°) ≈ -0.17, cos(350°) ≈ 0.98입니다. 모든 sin 값의 평균과 cos 값의 평균을 구한 뒤, atan2(평균sin, 평균cos)로 최종 방향을 계산합니다.

350도와 10도의 경우, 평균 sin ≈ 0, 평균 cos ≈ 1이 되어 atan2(0, 1) = 0도(북풍)가 나옵니다. 삼각함수를 사용하면 방향 값들을 2차원 벡터로 취급할 수 있어, 원형 데이터의 평균을 올바르게 계산할 수 있습니다.

### 필요할 때만 조회하는 Lazy Trigger

대시보드 상단에는 여러 통계 카드가 좌우 스와이프로 전환됩니다. 파도 정보 카드, 바람 정보 카드, 지역 평균 카드 등이 있는데, 사용자가 실제로 해당 카드를 볼 때만 데이터를 조회하도록 구현했습니다.

RxSwift의 PublishRelay를 사용해 스와이프 이벤트를 방출하고, flatMapLatest로 이전 조회를 취소하면서 새로운 조회를 시작합니다. 사용자가 지역 평균 카드를 보지 않으면 10개 해변 병렬 조회가 실행되지 않습니다.

### 10배 빨라졌지만 10배 비싸졌다

API 응답 시간은 30초에서 3초로 10배 개선되었습니다. 사용자 경험은 크게 향상되었지만, Firebase Firestore의 읽기 요청 횟수도 10배 증가했습니다. 단일 조회는 1회 읽기, 병렬 조회는 10회 읽기를 소비합니다.

현재는 Firebase 무료 쿼터(일 50,000회)로 충분하지만, 사용자가 늘어나면 비용 문제가 발생할 수 있습니다. 조회 결과를 메모리에 캐싱하고 TTL(Time To Live)을 6시간으로 설정하면, 같은 데이터를 반복 조회하지 않아 비용을 줄일 수 있습니다.

### maxConcurrent는 높을수록 좋지 않다

처음에는 maxConcurrent를 20으로 설정했습니다. 더 많은 요청을 동시에 처리하면 더 빠를 것이라 예상했습니다. 그러나 실제로는 일부 요청이 타임아웃되거나 연결 실패가 발생했습니다.

iOS의 URLSession은 동일 호스트에 대해 기본적으로 4~6개의 동시 연결만 허용합니다. 이를 초과하는 요청은 큐에서 대기하게 되어, 높은 maxConcurrent 값은 의미가 없습니다. 양양 지역 해변이 최대 14개이고 시스템 제약을 고려해 10으로 설정했습니다.

### 시간 범위 필터링이 필요하다

현재는 오늘과 내일의 모든 시간대 데이터(약 16개 시간대)를 조회합니다. 그러나 사용자에게 실제로 필요한 것은 현재 시간 전후 3시간 정도입니다. Firestore 쿼리에 where 조건으로 시간 범위를 추가하면, 전송되는 데이터량을 절반 이상 줄일 수 있습니다. 비용 절감과 응답 속도 개선이 동시에 가능한 최우선 개선 과제입니다.

---

## 2. 해양 물리 공식으로 누락 데이터 추정

### 신뢰할 수 없는 기상청 API

기상청 API에서 받은 데이터에 NaN이나 -900 같은 이상값이 섞여 있었습니다. 파고가 -900미터이거나, 풍속이 NaN인 경우가 실제로 발생했습니다. 이런 데이터를 그대로 차트에 표시하면 빈 공간이 생기거나 앱이 크래시됩니다.

더 큰 문제는 파도 주기(wave period) 데이터가 아예 제공되지 않는다는 점이었습니다. 파도 주기는 서퍼들이 파도의 힘을 판단하는 중요한 지표인데, 기상청 API에는 이 값이 없었습니다.

### Pierson-Moskowitz 공식 적용

해양 물리학에서는 풍속과 파도 주기 사이의 상관관계를 연구한 Pierson-Moskowitz 공식이 있습니다. 이 공식은 Tp ≈ 0.83 × U10 관계를 제시합니다. Tp는 파도 주기(초), U10은 해상 10미터 높이의 풍속(m/s)입니다.

예를 들어 풍속이 12m/s라면, 파도 주기는 약 10초(0.83 × 12)로 추정할 수 있습니다. 이 공식은 완전히 발달된 바다(fully developed sea)를 가정하므로 연안 지역에서는 정확도가 떨어지지만, 데이터가 아예 없는 것보다는 훨씬 낫습니다.

### 3단계 데이터 검증 파이프라인

Firestore에서 데이터를 받으면 DTO 레벨에서 검증이 시작됩니다. 첫 번째 단계는 범위 검사입니다. 파고는 0~10미터, 풍속은 0~30m/s, 수온은 0~35도 범위를 벗어나면 nil로 처리합니다.

두 번째 단계는 NaN과 특수값 제거입니다. isNaN 체크와 함께 -900, -999 같은 센티널 값도 필터링합니다. 기상청 API는 데이터가 없을 때 명시적으로 null을 보내지 않고 -900을 보내는 경우가 있었습니다.

세 번째 단계는 누락 데이터 추정입니다. 파도 주기가 nil이고 풍속 데이터가 유효하면 Pierson-Moskowitz 공식을 적용합니다. 추정값은 2초에서 18초 사이로 제한해 비현실적인 값을 방지합니다.

### 습도와 풍속으로 날씨 코드 계산

기상청 API는 날씨 상태 코드(맑음/흐림/비)를 제공하지 않았습니다. 습도, 풍속, 강수 확률 데이터만 있었습니다. 이 세 값을 조합해 날씨를 추론하는 규칙 기반 로직을 만들었습니다.

습도 80% 이상이면서 강수 확률 60% 이상이면 "비"로 분류합니다. 습도 70% 이상이거나 풍속 10m/s 이상이면 "흐림"입니다. 나머지는 "맑음"으로 처리합니다. 완벽하지는 않지만 대부분의 경우 실제 날씨와 일치했습니다.

### 차트 렌더링 실패가 15%에서 1%로

데이터 검증 로직을 구현하기 전에는 차트가 제대로 그려지지 않는 경우가 15% 정도 발생했습니다. 특정 시간대에 이상값이 있으면 해당 열 전체가 비거나, 앱이 크래시되었습니다.

검증 로직 적용 후 실패율이 1% 미만으로 떨어졌습니다. 남은 1%는 모든 데이터가 이상값인 극단적인 경우로, 이때는 "데이터를 불러올 수 없습니다" 메시지를 표시합니다.

### ±2초 오차의 의미

Pierson-Moskowitz 공식으로 추정한 파도 주기는 실제 값과 ±2초 정도 차이가 납니다. 실제 파도 주기가 8초인데 6초나 10초로 추정될 수 있다는 의미입니다.

서핑 조건 판단에는 "주기가 짧다(5초 미만) / 중간(5~10초) / 길다(10초 이상)" 정도의 구분이면 충분하므로, ±2초 오차는 허용 가능합니다. 그러나 전문적인 해양 예측이나 과학 연구에는 부적합한 정확도입니다.

### 소스 데이터 품질의 벽

검증 로직을 아무리 정교하게 만들어도, 원본 데이터 자체가 부정확하면 한계가 있습니다. 기상청 API가 잘못된 값을 보낸다면 그것을 "올바르게" 고칠 방법은 없습니다. 

향후 Open-Meteo나 NOAA 같은 다른 기상 API를 추가로 호출해 교차 검증하는 방안을 고려해야 합니다. 두 소스가 비슷한 값을 보내면 신뢰하고, 차이가 크면 사용자에게 "예보 불확실" 경고를 표시하는 식입니다.

---

## 3. 4개 센서를 통합한 서핑 추적

### Watch에서 무엇을 측정할 것인가

Apple Watch로 서핑을 추적하려면 HealthKit의 Workout API를 사용해야 합니다. 기본 메트릭인 심박수와 칼로리 소모만으로는 부족했습니다. 서퍼들이 원하는 것은 "몇 개의 파도를 탔는지", "얼마나 멀리 나갔는지", "패들링을 얼마나 했는지" 같은 정보입니다.

문제는 서핑이 복잡한 운동이라는 것입니다. 패들링, 파도 타기, 대기를 반복하며, 각 동작의 강도가 다릅니다. 단순히 시간과 심박수만으로는 서핑의 특성을 제대로 포착할 수 없습니다.

### HealthKit, CoreLocation, CoreMotion, CMAltimeter

네 개의 프레임워크를 조합했습니다. HealthKit으로 심박수와 칼로리를 측정하고, CoreLocation의 GPS로 이동 거리와 속도를 계산합니다. CoreMotion의 가속도계로 패들링 동작을 감지하고, CMAltimeter의 고도계로 파도를 탄 횟수를 추정합니다.

각 센서는 독립적인 업데이트 주기를 가집니다. 가속도계는 10Hz(초당 10회), GPS는 1Hz, 고도계는 약 1Hz, 심박수는 불규칙합니다. 이 비동기적인 데이터 스트림을 하나의 상태로 통합하는 것이 핵심 과제였습니다.

### Combine으로 센서 스트림 통합

Combine 프레임워크의 Publishers를 사용해 각 센서를 별도 스트림으로 만들었습니다. 가속도계는 PassthroughSubject로 10Hz 업데이트를 방출하고, GPS와 고도계도 마찬가지입니다.

combineLatest로 여러 스트림을 결합했지만, 업데이트 주기가 다르기 때문에 단순 결합은 문제가 있습니다. 가속도 데이터가 10번 업데이트되는 동안 GPS는 1번만 업데이트되므로, 최신 GPS 값을 계속 재사용해야 합니다. withLatestFrom 패턴으로 이를 구현했습니다.

### 가속도 2G 이상이면 패들링 중

패들링 동작은 팔을 빠르게 움직이므로 큰 가속도를 발생시킵니다. 가속도계에서 x, y, z 축 가속도의 크기(magnitude)를 계산하고, 이 값이 2G(중력 가속도의 2배, 약 19.6m/s²) 이상이면 패들링으로 판단했습니다.

2G 임계값은 제가 직접 서핑하며 수집한 데이터를 기반으로 설정했습니다. 1.5G는 너무 민감해서 단순히 팔을 움직여도 감지되었고, 2.5G는 너무 둔감해서 패들링을 놓쳤습니다. 2G가 적절한 균형점이었습니다.

### 고도 1m 변화로 파도 감지

파도를 탈 때는 수면에서 파도 마루로 올라갔다가 다시 내려옵니다. 이 고도 변화를 감지하면 파도를 탄 횟수를 셀 수 있습니다. CMAltimeter로 상대 고도를 측정하고, 1미터 이상 상승 후 하강하면 "파도 탐" 이벤트로 카운트합니다.

이 방법의 한계는 작은 파도(1미터 미만)를 놓친다는 것입니다. 초보자들이 주로 타는 0.5~0.8미터 파도는 감지되지 않습니다. 또한 사용자가 점프하거나 다이빙하는 경우도 파도로 카운트되는 오탐지가 있습니다.

### 최근 30초만 버퍼에 저장

10Hz 가속도 데이터를 모두 저장하면 1분에 600개 데이터 포인트가 쌓입니다. 1시간이면 36,000개입니다. Watch의 메모리는 제한적이므로 무한정 저장할 수 없습니다.

순환 버퍼(circular buffer)를 구현해 최근 30초 데이터만 유지했습니다. 30초마다 가장 오래된 데이터를 삭제하고 새 데이터를 추가합니다. 패들링 감지는 최근 데이터만 있으면 되므로, 과거 데이터를 보관할 필요가 없습니다.

### 화면 꺼지면 1Hz로 다운그레이드

Watch 화면이 켜져 있을 때는 10Hz로 업데이트해야 부드러운 UI를 보여줄 수 있습니다. 그러나 화면이 꺼지면 사용자가 보지 않으므로 높은 주기가 불필요합니다.

WKExtension의 applicationState를 감지해, 백그라운드로 전환되면 센서 업데이트를 1Hz로 낮췄습니다. 이렇게 하면 배터리 소모가 절반으로 줄어듭니다. 1시간 서핑 시 배터리 소모가 약 15%에서 8%로 감소했습니다.

### 80% 정확도의 한계

실제 서핑 20회를 테스트한 결과, 파도 감지 정확도는 약 80%였습니다. 10개 파도를 타면 8개는 정확히 카운트되지만, 2개는 놓치거나 오탐지됩니다.

오탐지의 주요 원인은 큰 너울에서 점프하거나, 보드에서 떨어져 다이빙하는 경우입니다. 고도 변화만으로는 "의도적으로 파도를 탄 것"과 "우연히 고도가 변한 것"을 구분할 수 없습니다.

### 머신러닝 모델로 개선 가능

가속도 패턴으로 패들링, 라이딩, 대기 상태를 분류하는 머신러닝 모델을 만들면 정확도를 크게 높일 수 있습니다. Create ML로 가속도 시계열 데이터를 학습시켜 동작 분류기를 만드는 것이 다음 단계입니다.

문제는 학습 데이터 수집입니다. 최소 100회 이상의 서핑 세션 데이터가 필요한데, 저 혼자 수집하기는 어렵습니다. 베타 테스터들에게 데이터 수집을 의뢰하거나, 공개 데이터셋을 찾아야 합니다.

---

## 4. 반응형 필터링

### if문 지옥

사용자가 서핑 기록을 필터링하고 정렬하는 조건이 많았습니다. "전체", "핀 고정만", "최근 7일", "이번 달", "특정 해변", "별점 4점 이상" 등을 자유롭게 조합할 수 있어야 했습니다.

명령형 코드로 구현하면 필터 변경 이벤트마다 if-else로 분기해야 합니다. 정렬도 마찬가지입니다. 필터 5가지 × 정렬 4가지 = 20개 조합을 모두 처리하려면 코드가 복잡해집니다.

### 3개 스트림을 하나로

RxSwift의 combineLatest로 세 개의 독립적인 스트림을 결합했습니다. 첫 번째는 Realm에서 가져온 전체 기록 리스트, 두 번째는 현재 필터 조건(BehaviorRelay), 세 번째는 정렬 기준(BehaviorRelay)입니다.

세 스트림 중 하나라도 변경되면 combineLatest가 자동으로 새로운 결과를 계산합니다. ViewController는 필터 버튼을 탭하면 filterRelay.accept(new value)만 호출하면 됩니다. ViewModel이 알아서 필터링과 정렬을 수행하고 결과를 TableView로 보냅니다.

### 날짜 범위 프리셋 계산

"오늘", "최근 7일", "이번 달", "지난 달" 같은 프리셋은 DateComponents로 정확히 계산해야 합니다. "이번 달"은 현재 달의 1일 00:00:00부터 마지막 날 23:59:59까지입니다.

Calendar.current.dateInterval(of: .month, for: Date())로 이번 달의 시작과 끝을 구합니다. "지난 달"은 현재 날짜에서 -1 month를 한 뒤 같은 방식으로 계산합니다. 시간대를 명시하지 않으면 UTC와 로컬 시간이 섞여 하루씩 오차가 발생할 수 있습니다.

### Pin 토글 후 즉시 반영

사용자가 기록의 Pin 아이콘을 탭하면 Realm에 즉시 기록됩니다. Realm은 Observable 객체를 제공하므로, 데이터 변경 시 자동으로 알림을 방출합니다.

이 알림이 combineLatest의 첫 번째 스트림(전체 기록)을 업데이트하고, 현재 필터가 "핀 고정만"이라면 리스트에서 해당 항목이 즉시 추가되거나 제거됩니다. 별도의 리프레시 로직이 필요 없습니다.

### 200줄이 50줄로

명령형으로 작성했다면 필터링 로직만 약 200줄이 필요했을 것입니다. filterType에 따라 switch 문으로 분기하고, sortType에 따라 또 분기하고, 각 케이스마다 배열 필터링과 정렬 코드를 작성해야 합니다.

combineLatest 패턴으로는 약 50줄로 같은 기능을 구현했습니다. 필터 로직은 하나의 함수로 추출하고, 정렬 로직도 하나의 함수로 분리했습니다. 새로운 필터를 추가할 때도 enum에 케이스만 추가하면 됩니다.

### 확장이 쉽다

"날짜 범위 직접 선택" 필터를 추가하려면, FilterType enum에 `.customDateRange(start: Date, end: Date)` 케이스를 추가하고, 필터링 함수에 해당 케이스 처리를 추가하면 됩니다. combineLatest 구조는 전혀 변경할 필요가 없습니다.

반면 명령형 코드는 if-else 체인에 새로운 분기를 추가해야 하고, 다른 조건과 충돌하지 않는지 확인해야 합니다. 코드가 복잡해질수록 버그 가능성이 높아집니다.

---

## 5. Watch 데이터 전송 확인

### 보냈는데 안 보여요

Watch에서 서핑 세션을 종료하고 iPhone으로 데이터를 전송하면, 사용자는 iPhone에서 기록이 나타나기를 기대합니다. 그러나 초기 구현에서는 전송 성공 여부를 알 수 없었습니다. "보냈는데 왜 안 보여요?"라는 피드백이 많았습니다.

WatchConnectivity의 sendMessage는 비동기적으로 동작하고, 전송 실패 시 에러 콜백만 호출됩니다. iPhone이 백그라운드에 있거나 블루투스 범위를 벗어나면 메시지가 사라집니다.

### replyHandler로 양방향 확인

sendMessage에는 replyHandler 파라미터가 있습니다. iPhone이 메시지를 받으면 응답 데이터를 보낼 수 있습니다. Watch는 이 응답을 받아 전송 성공을 확인합니다.

구체적으로, iPhone은 데이터를 Realm에 저장한 후 `["status": "success"]` 딕셔너리를 응답으로 보냅니다. 저장 실패 시 `["status": "error", "message": "저장 실패"]`를 보냅니다. Watch는 응답을 파싱해 성공/실패 UI를 표시합니다.

### async/await로 가독성 개선

WatchConnectivity는 completion handler 기반 API입니다. 중첩된 클로저가 많아지면 코드 가독성이 떨어집니다. Swift의 async/await가 더 명확합니다.

withCheckedThrowingContinuation을 사용해 completion handler를 async 함수로 변환했습니다. 이렇게 하면 do-catch로 에러를 처리할 수 있고, await로 응답을 기다릴 수 있습니다. 중첩 클로저가 사라져 코드가 선형적으로 읽힙니다.

### TimeInterval 검증

Watch에서 보낸 시작/종료 시간은 TimeInterval 타입입니다. 1970년 1월 1일 이후의 초 단위 시간이므로, Date(timeIntervalSince1970:)로 변환해야 합니다.

그러나 음수 값이 오거나, 미래 시간(현재 + 1분 이상)이 오면 명백히 잘못된 데이터입니다. 서핑 시간이 10시간을 초과하는 것도 비현실적입니다. 이런 경우 에러 응답을 보내고 저장을 거부합니다.

### isReachable 체크

메시지를 보내기 전에 WCSession.default.isReachable을 확인합니다. false이면 iPhone이 꺼져 있거나 블루투스 범위 밖에 있다는 의미입니다.

이때 즉시 실패 처리하지 않고, "iPhone을 켜고 가까이 두세요" 안내를 표시합니다. 사용자가 iPhone을 켜면 isReachable이 true로 바뀌고, 재전송 버튼을 활성화합니다.

### 95% 전송 성공률

100회 테스트에서 95회 성공했습니다. 실패한 5건은 iPhone이 완전히 꺼져 있거나(3건), 블루투스 범위를 벗어난 경우(2건)였습니다. 정상적인 사용 환경에서는 거의 100% 성공합니다.

### 재전송 큐가 없다

현재는 전송 실패 시 사용자가 수동으로 재전송 버튼을 눌러야 합니다. 서핑을 마치고 바로 바다에서 나오면 Watch와 iPhone이 멀리 떨어져 있을 수 있습니다.

이상적으로는 실패한 데이터를 Watch 로컬 스토리지에 저장하고, 백그라운드에서 주기적으로 재전송을 시도해야 합니다. WKApplicationRefreshBackgroundTask로 구현 가능하지만, Watch의 배터리 소모를 고려해야 합니다.

---

## 6. 요청 취소

### 3번 조회하고 2번 버리기

사용자가 해변 선택 드롭다운에서 양양 죽도, 양양 인구, 양양 기사문을 빠르게 클릭하면 3개 API 요청이 동시에 발생합니다. 실제로 화면에 표시될 데이터는 마지막 요청(양양 기사문)뿐입니다. 처음 두 요청은 불필요합니다.

네트워크 응답은 요청 순서와 다를 수 있습니다. 양양 기사문 응답이 먼저 도착하고 양양 인구 응답이 나중에 도착하면, 사용자는 양양 기사문을 선택했는데 양양 인구 데이터가 화면에 표시되는 버그를 경험합니다.

### flatMapLatest가 이전 요청을 취소한다

RxSwift의 flatMapLatest는 새로운 이벤트가 발생하면 이전 작업을 자동으로 취소합니다. 해변 선택 이벤트가 Observable 스트림으로 방출되고, flatMapLatest로 API 호출을 연결하면 됩니다.

내부적으로 이전 Observable의 DisposeBag이 dispose되어, 진행 중인 네트워크 요청의 URLSessionTask.cancel()이 호출됩니다. 응답이 도착해도 이미 구독이 해제되었으므로 무시됩니다.

### debounce로 입력 억제

사용자가 해변을 선택하는 순간마다 API를 호출하는 것은 비효율적입니다. debounce(120ms)를 추가하면, 마지막 입력 후 120ms 동안 추가 입력이 없을 때만 API를 호출합니다.

사용자가 리스트를 빠르게 스크롤하며 여러 항목을 지나치면, 중간 항목들은 debounce에 의해 필터링됩니다. 120ms는 사용자가 체감할 수 없을 정도로 짧으면서도, 빠른 연속 입력을 걸러내기에 충분합니다.

### 백그라운드 스레드와 메인 스레드

API 호출은 백그라운드 스레드에서 실행되어야 메인 스레드가 블로킹되지 않습니다. subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))로 백그라운드 실행을 명시합니다.

응답 처리는 메인 스레드에서 이루어져야 UI를 업데이트할 수 있습니다. observe(on: MainScheduler.instance)로 메인 스레드로 전환합니다. 이 두 스케줄러를 빠뜨리면 "UI updates must be on main thread" 경고가 발생합니다.

### 불필요한 API 호출 50% 감소

flatMapLatest 적용 전에는 사용자가 빠르게 5개 해변을 선택하면 5개 요청이 모두 발생했습니다. 적용 후에는 마지막 1개만 유효하고 나머지 4개는 취소됩니다.

debounce를 추가한 후 총 API 호출 횟수가 절반으로 줄었습니다. 사용자가 목표 해변을 찾기 위해 리스트를 스크롤할 때, 중간에 지나친 해변들은 API가 호출되지 않습니다.

### 취소해도 서버는 실행한다

flatMapLatest는 클라이언트에서 응답을 무시할 뿐, 이미 전송된 네트워크 패킷은 취소할 수 없습니다. 요청이 Firebase에 도착해 처리 중이라면 서버 리소스는 이미 소비된 상태입니다.

클라이언트는 Firestore 읽기 쿼터를 절약하지 못합니다. 응답을 받지 않아도 읽기 1회가 차감됩니다. debounce가 더 근본적인 해결책입니다. 아예 요청을 보내지 않으면 서버 비용도 절약됩니다.

---

**전체 재작성 완료. 각 구현마다 구조와 톤이 다릅니다.**
