1. 지역평균 카드  
구현 위치 `DoSurfApp/Presentation/ViewModel/DashboardViewModel.swift`  
기획서 연결  
* 문제 정의: 초보자는 각 해변 예보를 모두 비교하기 어렵다  
* 핵심 기능/가치 연결: “초보자 친화” 요약 정보, “한국 특화(지역 평균)”  

기술적 도전  
* 같은 지역 해변 10개 내외를 동시에 조회하고 7일치 데이터를 집계해야 했다  
* 일반적인 순차 요청은 2~3초 이상 지연되어 카드가 늦게 뜨는 문제가 있었다  
* 풍향/파향은 단순 평균이 왜곡되어 “잘못된 방향”을 보여줄 위험이 있었다  

해결 접근  
* RxSwift `flatMapConcurrent`로 병렬 요청 + `cardsLazyTrigger`로 지연 로딩  
* 평균 방향은 벡터 합(사인/코사인)으로 계산해 원형 데이터 왜곡 방지  
* 결과를 지역 키로 캐시해 재방문 시 재계산 최소화  
* UX: 카드 먼저 표시 → 평균 카드 늦게 채움으로 체감 속도 개선  

차별화 포인트  
* 데이터 집계 로직과 원형 평균까지 설계해 단순 API 소비를 넘어섬  
* 역량: A(데이터 처리), C(아키텍처), E(성능), F(프로덕트)  
* AI 코드에 잘 없는 “방향 평균” 같은 도메인 판단을 보여줌  

성과/학습  
* 정량 지표는 미집계, 체감 로딩 지연 감소  
* 병렬 처리와 지연 로딩의 균형을 학습  
* 다음엔 캐시 만료/재계산 정책을 추가하고 싶다  

카테고리: A/C/E/F  
복잡도: ⭐️⭐️⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

2. 시간대 자동포커싱  
구현 위치 `DoSurfApp/Presentation/Scenes/Dashboard/DashboardViewController.swift`  
기획서 연결  
* 문제 정의: 앱 재진입 시 사용자가 현재 시간대 예보를 찾기 번거롭다  
* 핵심 기능/가치 연결: “초보자 친화” 빠른 정보 접근  

기술적 도전  
* 앱이 백그라운드/포그라운드로 전환될 때도 안정적으로 포커싱해야 했다  
* 일반적인 방식은 새로고침만 수행해 사용자가 스크롤을 다시 찾아야 했다  
* UX 지연이 생기면 “앱이 느리다”는 인상이 강해졌다  

해결 접근  
* `UIApplication.didBecomeActiveNotification`을 Rx로 구독해 재활성화 이벤트 감지  
* 현재 시간 기준으로 `focusOnUpcomingChart()`를 호출해 자동 포커싱  
* UX: 재진입 순간 바로 현재 예보가 보이도록 흐름 최적화  

차별화 포인트  
* 단순 UI 갱신이 아니라 “재진입 순간의 사용자 행동”을 고려한 설계  
* 역량: F(프로덕트 사고), D(예외 처리)  
* AI 코드에 잘 없는 “재활성화 컨텍스트 UX”를 보여줌  

성과/학습  
* 정량 지표는 미집계, 재진입 시 탐색 시간 감소  
* 이벤트 기반 UX 설계의 중요성을 학습  
* 다음엔 상태 복원 + 스크롤 위치 유지까지 확장하고 싶다  

카테고리: F/D  
복잡도: ⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

3. 메모자동 저장  
구현 위치 `DoSurfApp/Presentation/ViewModel/NoteViewModel.swift`  
기획서 연결  
* 문제 정의: 기록 작성 중 이탈/앱 종료 시 메모 손실 위험  
* 핵심 기능/가치 연결: “개인화 기록”, “초보자 친화(자동 저장)”  

기술적 도전  
* 메모 입력 스트림이 잦아 저장 타이밍을 잘못 잡으면 UX가 깨진다  
* 일반적인 저장은 “저장 버튼”에만 의존해 중간 이탈에 취약하다  
* 시간대 스냅샷 필터링도 동시에 동작해야 했다  

해결 접근  
* RxSwift로 메모 변경 스트림을 UserDefaults에 즉시 임시 저장  
* KST 기준 3시간 슬롯 정렬로 차트 스냅샷을 일관되게 필터링  
* 저장 성공 시 임시 키를 제거해 중복 복원 방지  
* UX: 작성 중 앱이 꺼져도 다음 진입 시 자동 복원  

차별화 포인트  
* CRUD가 아니라 “작성 중 손실”까지 고려한 설계  
* 역량: A(데이터 처리), C(아키텍처), F(프로덕트)  
* AI 코드가 잘 놓치는 “이탈 대응 UX”를 강조  

성과/학습  
* 정량 지표는 미집계, 메모 손실 리스크 감소  
* 시간대/로케일 고려가 데이터 정확성에 중요함을 학습  
* 다음엔 백그라운드 저장 타이밍을 더 정교화하고 싶다  

카테고리: A/C/F  
복잡도: ⭐️⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

4. 서핑상태 복원  
구현 위치 `DoSurfApp/Presentation/ViewModel/ButtonTabBarViewModel.swift`, `DoSurfApp/Infra/UserDefaultsManager.swift`, `DoSurfApp/Domain/Service/SurfingActivityManager.swift`  
기획서 연결  
* 문제 정의: 서핑 중 앱 종료/재시작 시 세션이 끊기면 신뢰도 하락  
* 핵심 기능/가치 연결: “서핑 중 상태 지속”, “멀티 디바이스 + Live Activity”  

기술적 도전  
* 상태 복원과 Live Activity 재시작이 함께 맞물려야 했다  
* 일반적인 세션 관리는 메모리 상태에 의존해 재시작 시 끊긴다  
* 권한 비활성화/시뮬레이터 같은 예외 환경이 많았다  

해결 접근  
* UserDefaults에 서핑 상태/시작/종료 시간을 저장해 복원 가능하게 설계  
* 앱 초기 로드 시 상태 확인 후 Live Activity 재시작  
* 종료/취소 분기마다 상태를 명확히 정리해 데이터 일관성 확보  
* UX: 재실행 후에도 “서핑 중” 경험이 이어짐  

차별화 포인트  
* ActivityKit 연결을 넘어 “상태 복원”까지 설계  
* 역량: B(플랫폼), D(예외 처리), F(프로덕트)  
* 실사용 시나리오를 반영한 안정성 설계가 차별화  

성과/학습  
* 정량 지표는 미집계, 세션 이탈 불만 가능성 감소  
* 상태 복원이 제품 신뢰에 미치는 영향을 학습  
* 다음엔 종료 조건 자동화와 복구 시나리오를 강화하고 싶다  

카테고리: B/D/F  
복잡도: ⭐️⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

5. Live Activity 타이머 업데이트  
구현 위치 `DoSurfApp/Domain/Service/SurfingActivityManager.swift`  
기획서 연결  
* 문제 정의: 잠금화면/다이내믹 아일랜드에서 경과시간이 지속적으로 보여야 한다  
* 핵심 기능/가치 연결: “멀티 디바이스 경험”, 서핑 중 상태 가시화  

기술적 도전  
* ActivityKit 업데이트는 비동기이기 때문에 타이머와 동기화가 필요했다  
* 일반적인 1회 표시만으로는 “서핑 중”을 실감하기 어렵다  
* iOS 버전/권한/시뮬레이터 등 환경별 예외가 많았다  

해결 접근  
* 60초 타이머로 경과 시간을 주기적으로 업데이트  
* 시작 즉시 1회 업데이트를 추가해 초기 빈 상태를 방지  
* 실패 케이스는 로그와 안내 메시지로 진단 가능하게 처리  
* UX: 사용자가 잠금화면에서 “현재 진행 중”을 바로 확인  

차별화 포인트  
* 단순 표시가 아니라 “진행 상태를 유지”하는 Live Activity 설계  
* 역량: B(플랫폼), E(성능)  
* ActivityKit 동작 특성을 고려한 업데이트 전략을 보여줌  

성과/학습  
* 정량 지표는 미집계, 진행 중 가시성 개선  
* 실시간 UI는 타이밍 설계가 핵심임을 학습  
* 다음엔 배터리 영향/업데이트 주기 튜닝을 시도하고 싶다  

카테고리: B/E  
복잡도: ⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

6. 워치 자동 감지  
구현 위치 `DoSurfWatch Watch App/SurfWorkoutManager.swift`  
기획서 연결  
* 문제 정의: 사용자가 항상 시작/종료를 누르지 않아도 자동으로 서핑을 감지해야 한다  
* 핵심 기능/가치 연결: “멀티 디바이스”, “초보자 친화(자동 감지)”  

기술적 도전  
* 10Hz 센서 데이터는 노이즈가 많고 오탐/미탐 위험이 컸다  
* 일반적인 운동 추적은 서핑 특성을 반영하지 못했다  
* 파도 감지/패들링 감지 같은 도메인 규칙이 필요했다  

해결 접근  
* 고도 변화 1m 이상 + 5초 쿨다운 규칙으로 파도 감지  
* 가속도 합산 임계값으로 서핑 활동 감지  
* 패들링은 팔 움직임 패턴으로 보조 지표 추출  
* UX: 자동 감지로 시작/종료 스트레스를 줄임  

차별화 포인트  
* 센서 융합 규칙을 직접 설계해 “서핑 특화”를 구현  
* 역량: B(플랫폼), E(성능), F(프로덕트)  
* AI 코드가 잘 다루지 못하는 센서 해석 로직을 강조  

성과/학습  
* 정량 지표는 미집계, 자동 감지 기반 시나리오 완성도 향상  
* 노이즈 환경에서 “정확도보다 안정성”이 중요함을 학습  
* 다음엔 머신러닝 기반 분류로 확장하고 싶다  

카테고리: B/E/F  
복잡도: ⭐️⭐️⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

7. 워치↔폰 전송  
구현 위치 `DoSurfWatch Watch App/WatchConnectivityManager.swift`, `DoSurfApp/Infra/iPhoneWatchConnectivity.swift`, `DoSurfApp/Infra/SurfDataReceiverViewController.swift`  
기획서 연결  
* 문제 정의: 워치에서 수집한 세션 요약이 iPhone 기록으로 이어져야 한다  
* 핵심 기능/가치 연결: “멀티 디바이스 경험”  

기술적 도전  
* 연결 불가/파싱 실패 등 예외 상황이 잦다  
* 일반적인 전송은 데이터만 보내고 수신 확인 UX가 없다  
* 시간/거리/심박 데이터 타입 매핑이 정확해야 한다  

해결 접근  
* WatchConnectivity 메시지를 Codable 구조로 정의하고 파싱 실패 시 에러 처리  
* iPhone 수신 화면에서 연결 상태/마지막 수신 시간을 명확히 표시  
* 응답 메시지로 전송 성공 여부를 회신 가능하게 설계  
* UX: “데이터가 실제로 전달되었다”는 신뢰 확보  

차별화 포인트  
* 전송 파이프라인 + 수신 UX까지 포함한 설계  
* 역량: B(플랫폼), D(예외 처리), F(프로덕트)  
* “전송 성공 확인”까지 고려한 운영 시나리오를 강조  

성과/학습  
* 정량 지표는 미집계, 데이터 수신 신뢰도 향상  
* 연결 안정성은 UX와 직결됨을 학습  
* 다음엔 백그라운드 전송/재전송 큐를 추가하고 싶다  

카테고리: B/D/F  
복잡도: ⭐️⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  

8. 차트셀 캐시  
구현 위치 `DoSurfApp/Presentation/Scenes/Dashboard/ChartTableViewCell.swift`  
기획서 연결  
* 문제 정의: 해양 예보 리스트는 길고, 스크롤 시 렌더링 비용이 크다  
* 핵심 기능/가치 연결: “초보자 친화” 빠른 피드백, 성능 안정성  

기술적 도전  
* 각 셀에서 아이콘 회전/이미지 변경이 반복되면 렌더링 부담이 컸다  
* 일반적인 셀 구성은 스크롤 시 프레임 드랍이 생길 수 있다  
* 동일 값 재적용을 줄여야 했다  

해결 접근  
* 풍향/파향/날씨 아이콘에 캐시 변수를 두고 동일 값이면 갱신 생략  
* 레이아웃 스택 구조를 단순화해 리플로우 비용을 줄임  
* UX: 긴 리스트에서도 부드러운 스크롤 유지  

차별화 포인트  
* 단순 UI가 아니라 “재렌더링 비용”을 줄이는 실전 최적화  
* 역량: E(성능 관리)  
* 주니어라도 성능 병목을 인식하고 대응한 사례  

성과/학습  
* 정량 지표는 미집계, 스크롤 체감 성능 개선  
* 작은 캐시가 큰 UX 차이를 만들 수 있음을 학습  
* 다음엔 이미지/데이터 캐싱 정책까지 확장하고 싶다  

카테고리: E  
복잡도: ⭐️⭐️  
주니어 어필도: ⭐️⭐️⭐️  
면접 예상 질문 3개  
1. "이 기능을 구현하면서 가장 어려웠던 점은?"  
2. "왜 이 방식을 선택했나요?"  
3. "다시 구현한다면 어떻게 개선하겠습니까?"  
