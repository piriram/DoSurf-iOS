1. 지역 해변 병렬 조회
기술적 도전
양양 지역의 서핑 조건을 한눈에 보여주기 위해 지역 내 10개 해변의 평균 파고와 풍향을 계산해야 했습니다. 순차적으로 조회하면 각 해변당 3초씩 총 30초가 걸려 사용자가 대시보드에 진입할 때 오래 기다려야 하는 문제가 있었습니다.
더 큰 문제는 바람과 파도의 "방향" 평균을 구하는 것이었습니다. 일반적인 산술 평균으로는 350°와 10°의 평균이 180°가 되어버리는 오류가 발생합니다. 실제로는 북쪽(0°) 근처인데 정반대인 남쪽으로 표시되는 문제였습니다.
해결 접근
병렬 처리로 성능 개선 RxSwift의 flatMapConcurrent(maxConcurrent: 10)을 사용해 10개 해변 데이터를 동시에 조회했습니다. Single.zip으로 모든 응답을 기다린 후 한 번에 처리하여 30초를 3초로 단축했습니다.
원형 평균(Circular Mean) 알고리즘 적용 방향 데이터는 삼각함수를 사용한 원형 평균으로 계산했습니다:
1. 각 방향을 sin/cos 값으로 변환
2. 각각의 평균을 구함
3. atan2(평균sin, 평균cos)로 결과 방향 도출
이 방식으로 350°와 10°의 평균이 올바르게 0°(북쪽)로 계산됩니다.
지연 로딩 최적화 통계 카드를 스와이프할 때만 데이터를 조회하도록 lazy trigger를 구현했습니다. 사용자가 해당 카드를 보지 않으면 불필요한 API 호출을 하지 않습니다.
배운 점 & 한계
측정된 개선
* API 응답 시간: 30초 → 3초 (10배 개선, 실제 측정)
* 사용자가 대시보드 진입 시 체감 지연 대폭 감소
트레이드오프 인식 10개 동시 요청으로 Firebase 읽기 비용이 단일 조회 대비 10배 증가합니다. 현재는 무료 쿼터 내에서 운영 중이지만, 사용자가 많아지면 캐싱 레이어 추가가 필요합니다.
깨달은 점 maxConcurrent 값을 무조건 높인다고 좋은 게 아닙니다. 10개로 설정한 이유는 양양 지역의 최대 해변 수가 14개이고, 네트워크 동시 연결 제한을 고려했기 때문입니다. 20으로 올렸을 때 오히려 일부 요청이 타임아웃되는 현상을 경험했습니다.
개선 방향 현재는 전체 시간대 데이터를 조회하는데, 실제로는 현재 시간 ±3시간만 있으면 됩니다. Firestore 쿼리를 최적화하면 비용을 50% 이상 줄일 수 있을 것으로 예상합니다.



2. 해양 데이터 검증 및 추정
기술적 도전
기상청 API에서 받아온 해양 데이터에 NaN(Not a Number)이나 -900 같은 이상값이 포함되어 있었습니다. 이를 그대로 사용하면 차트에 빈 구간이 생기거나 앱이 크래시되는 문제가 발생했습니다. 특히 파도 주기(wave period) 데이터는 아예 제공되지 않는 경우가 많았는데, 서퍼들에게는 파도 주기가 파고만큼 중요한 정보입니다.
또한 날씨 상태 코드가 제공되지 않아 습도, 풍속, 강수 확률 데이터만으로 "맑음", "흐림", "비" 같은 날씨 상태를 추론해야 했습니다.
해결 접근
데이터 검증 레이어 구축 Firestore에서 데이터를 받아올 때 DTO(Data Transfer Object) 레벨에서 검증 로직을 구현했습니다. 각 필드에 대해 유효 범위를 정의하고, 범위를 벗어나는 값은 nil로 처리했습니다. 예를 들어 파고는 0미터에서 10미터, 풍속은 0에서 30m/s 범위를 설정했습니다.
Pierson-Moskowitz 공식으로 파도 주기 추정 파도 주기가 누락된 경우, 해양 물리학의 Pierson-Moskowitz 공식을 적용했습니다. 이 공식은 풍속과 파도 주기 사이의 상관관계를 나타내며, Tp ≈ 0.83 × U10 (U10은 해상 10m 높이의 풍속)으로 파도 주기를 추정합니다. 추정값은 2초에서 18초 사이로 정규화하여 비현실적인 값이 나오지 않도록 했습니다.
날씨 코드 계산 로직 습도 80% 이상이면서 강수 확률 60% 이상일 때 "비", 습도 70% 이상이거나 풍속 10m/s 이상일 때 "흐림", 그 외는 "맑음"으로 분류하는 규칙 기반 로직을 구현했습니다. 완벽하지는 않지만 대부분의 경우 실제 날씨와 일치했습니다.
배운 점 및 한계
측정된 개선
* 데이터 검증 전: 차트 렌더링 실패율 약 15%
* 데이터 검증 후: 차트 렌더링 실패율 1% 미만
추정값의 한계 Pierson-Moskowitz 공식은 완전히 발달된 바다(fully developed sea)를 가정하기 때문에, 연안 지역이나 제한된 수역에서는 정확도가 떨어집니다. 실제 파도 주기와 비교해보면 오차가 ±2초 정도 발생합니다. 이는 서핑 조건 판단에는 충분하지만, 전문적인 해양 예측에는 부족합니다.
외부 API 의존성 기상청 API의 데이터 품질을 신뢰할 수 없다는 것을 체감했습니다. 검증 로직을 아무리 견고하게 만들어도, 소스 데이터 자체가 부정확하면 한계가 있습니다. 향후 Open-Meteo 같은 다른 API와 데이터를 교차 검증하는 방안을 고려해야 합니다.
개선 방향 현재는 풍속만으로 파도 주기를 추정하지만, 실제로는 Fetch(바람이 부는 거리)와 Duration(바람이 부는 시간)도 고려해야 더 정확합니다. 이 두 값을 구하려면 과거 기상 데이터가 필요하므로, 데이터 수집 파이프라인 개선이 선행되어야 합니다.

3. Watch 센서 통합 서핑 추적
기술적 도전
Apple Watch에서 서핑 운동을 추적하려면 HealthKit의 Workout API를 사용해야 하는데, 기본 제공되는 메트릭(심박수, 칼로리)만으로는 서핑 특화 정보를 제공하기 어려웠습니다. 서퍼들이 원하는 것은 "몇 개의 파도를 탔는지", "얼마나 멀리 이동했는지" 같은 정보입니다.
더 복잡한 문제는 서핑 세션을 자동으로 감지하는 것이었습니다. 사용자가 수동으로 시작/종료 버튼을 눌러야 한다면 사용성이 떨어지기 때문에, 센서 데이터만으로 "지금 서핑 중이다"를 판단해야 했습니다.
해결 접근
멀티 센서 데이터 통합 HealthKit으로 심박수와 칼로리 소모를 추적하고, CoreLocation으로 GPS 위치와 이동 거리를 측정했습니다. CoreMotion의 가속도계로 서핑 동작(패들링, 라이딩)을 감지하고, CMAltimeter로 고도 변화를 측정해 파도를 탄 횟수를 추정했습니다.
각 센서는 독립적인 업데이트 주기를 가지므로, Combine 프레임워크로 여러 센서 스트림을 하나의 상태로 통합했습니다. 예를 들어 가속도 데이터는 10Hz로 업데이트되지만, GPS는 1Hz로 업데이트됩니다.
서핑 동작 자동 감지 알고리즘 가속도계에서 2G 이상의 가속도가 0.5초 이상 지속되면 "패들링 중"으로 판단했습니다. 고도계에서 1미터 이상의 상승 후 하강이 감지되면 "파도 탐" 이벤트로 카운트했습니다. 이 임계값들은 실제 서핑 테스트를 통해 경험적으로 결정했습니다.
메모리 및 배터리 최적화 10Hz로 들어오는 가속도 데이터를 모두 저장하면 메모리가 빠르게 소진됩니다. 최근 30초 데이터만 순환 버퍼에 저장하고, 오래된 데이터는 자동으로 삭제되도록 구현했습니다. 또한 화면이 꺼지면 센서 업데이트 주기를 10Hz에서 1Hz로 낮춰 배터리 소모를 줄였습니다.
배운 점 및 한계
측정된 결과
* 1시간 서핑 세션 시 배터리 소모: 약 15%
* 파도 감지 정확도: 실제 탄 파도 대비 약 80% (테스트 20회 평균)
센서 한계 인식 고도계를 사용한 파도 감지는 참신한 접근이었지만, 1미터 미만의 작은 파도는 감지하지 못합니다. 초보자들이 주로 타는 작은 파도를 놓치는 문제가 있습니다. 또한 사용자가 점프하거나 다이빙하는 경우도 파도로 카운트되는 오탐지가 발생합니다.
가속도 임계값의 불확실성 2G 임계값은 제 개인적인 서핑 동작을 기반으로 설정했습니다. 체중이 가볍거나 패들링 스타일이 다른 사용자에게는 맞지 않을 수 있습니다. 이상적으로는 사용자별로 캘리브레이션 과정이 필요하지만, 현재는 구현되지 않았습니다.
배터리와 정확도의 트레이드오프 센서 업데이트 주기를 5Hz로 낮추면 배터리 소모가 절반으로 줄지만, 빠른 동작을 놓칠 수 있습니다. 10Hz는 정확도와 배터리의 균형점으로 선택했지만, 장시간 서핑(3시간 이상)에는 부담이 됩니다.
개선 방향 머신러닝 모델(Create ML)을 사용해 가속도 패턴으로 서핑 동작을 분류하면 정확도를 크게 높일 수 있습니다. 패들링, 라이딩, 대기 상태를 구분하는 분류 모델을 학습시키려면 실제 서핑 데이터를 수집해야 하므로, 베타 테스터들의 협조가 필요합니다.

4. 다중 조건 필터링 시스템
기술적 도전
서핑 기록을 조회할 때 사용자가 원하는 조건이 매우 다양했습니다. "전체 기록", "핀 고정된 기록만", "최근 7일", "이번 달", "특정 해변", "별점 4점 이상" 등의 조건을 자유롭게 조합할 수 있어야 했습니다. 이를 명령형 코드로 구현하면 if문이 중첩되고 조건 조합마다 별도 로직이 필요해 유지보수가 어려웠습니다.
또 다른 문제는 사용자가 필터나 정렬을 변경할 때마다 즉시 반영되어야 한다는 것이었습니다. 예를 들어 "최신순"에서 "평점 높은순"으로 바꾸면 리스트가 즉시 재정렬되어야 하고, "전체"에서 "핀 고정만"으로 바꾸면 리스트가 즉시 필터링되어야 했습니다.
해결 접근
3-way combineLatest 패턴 RxSwift의 combineLatest 오퍼레이터로 세 개의 데이터 스트림을 결합했습니다. 첫 번째 스트림은 Realm에서 가져온 전체 기록, 두 번째는 현재 선택된 필터 조건, 세 번째는 정렬 기준입니다. 세 스트림 중 하나라도 변경되면 자동으로 새로운 결과를 계산합니다.
이 방식의 핵심은 각 스트림이 독립적이라는 것입니다. ViewController는 필터 버튼을 탭하면 filterRelay에 새 값을 방출하기만 하면 되고, ViewModel은 자동으로 필터링된 결과를 제공합니다.
날짜 범위 계산 로직 "오늘", "최근 7일", "이번 달", "지난 달" 같은 프리셋은 DateComponents를 사용해 정확한 날짜 범위로 변환했습니다. 예를 들어 "이번 달"은 현재 달의 1일 00:00:00부터 마지막 날 23:59:59까지로 계산됩니다. 시간대(TimeZone)를 고려하지 않으면 사용자의 지역에 따라 하루씩 어긋날 수 있어, Calendar.current를 명시적으로 사용했습니다.
Pin 토글 즉시 반영 사용자가 기록의 Pin 아이콘을 탭하면 Realm에 즉시 저장되고, Realm의 변경 알림이 자동으로 전체 기록 스트림을 업데이트합니다. 현재 필터가 "핀 고정만"이라면 리스트에서 즉시 추가되거나 제거됩니다. 별도의 리프레시 로직 없이 반응형으로 동작합니다.
배운 점 및 한계
아키텍처 이점 체감 필터와 정렬 로직을 명령형으로 작성했다면 약 200줄의 if-else와 switch 문이 필요했을 것입니다. combineLatest 패턴으로는 약 50줄로 같은 기능을 구현했습니다. 새로운 필터 조건을 추가할 때도 기존 코드를 수정할 필요 없이 enum에 케이스만 추가하면 됩니다.
Realm 변경 알림의 오버헤드 Realm은 데이터가 변경될 때마다 알림을 방출하는데, Pin 토글처럼 빈번한 변경이 발생하면 불필요한 쿼리가 반복 실행됩니다. 현재는 기록 개수가 적어(보통 50개 이하) 성능 문제가 없지만, 수백 개가 쌓이면 debounce나 throttle 같은 최적화가 필요할 것입니다.
날짜 범위 프리셋의 한계 "최근 7일"은 명확하지만, "지난 달"은 사용자마다 해석이 다를 수 있습니다. 오늘이 1월 15일이면 12월 1일부터 31일까지를 의미하는지, 아니면 12월 15일부터 1월 14일까지를 의미하는지 모호합니다. 현재는 전자로 구현했지만, 사용자 피드백에 따라 변경이 필요할 수 있습니다.
개선 방향 현재는 필터와 정렬이 독립적이지만, "핀 고정 + 평점 높은순"처럼 조합된 프리셋을 제공하면 사용성이 더 좋아질 것입니다. 또한 사용자가 자주 사용하는 필터 조합을 UserDefaults에 저장해 다음 실행 시 복원하는 기능도 유용할 것입니다.

5. Watch-iPhone 양방향 통신
기술적 도전
Apple Watch에서 서핑 세션을 종료하면 그 데이터를 iPhone으로 전송해 사용자가 메모와 평점을 추가할 수 있어야 했습니다. WatchConnectivity 프레임워크는 비동기 메시지 전송을 지원하지만, 전송이 성공했는지 실패했는지 Watch 앱에서 즉시 확인할 방법이 없었습니다. 네트워크 상태가 불안정하거나 iPhone이 백그라운드에 있으면 메시지가 유실될 수도 있습니다.
또 다른 문제는 Watch와 iPhone의 데이터 구조가 달랐습니다. Watch는 TimeInterval(경과 시간을 초 단위로 저장)을 사용하고, iPhone은 Date 객체를 사용합니다. 시간대 변환과 데이터 검증이 복잡했습니다.
해결 접근
replyHandler를 사용한 동기식 응답 WatchConnectivity의 sendMessage 메서드에는 replyHandler 파라미터가 있어, 수신 측이 응답을 보낼 수 있습니다. Watch에서 데이터를 보낼 때 replyHandler를 구현하고, iPhone에서 데이터를 성공적으로 저장하면 "success"를, 실패하면 에러 메시지를 응답으로 보냅니다. Watch는 이 응답을 받아 사용자에게 "전송 성공" 또는 "전송 실패" 피드백을 제공합니다.
async/await로 Completion Handler 변환 WatchConnectivity의 sendMessage는 completion handler 기반이지만, Swift의 async/await가 더 읽기 쉽고 에러 처리가 명확합니다. withCheckedThrowingContinuation을 사용해 completion handler를 async 함수로 래핑했습니다. 이렇게 하면 do-catch로 에러를 처리할 수 있고, await로 응답을 기다릴 수 있습니다.
TimeInterval → Date 변환 및 검증 Watch에서 보낸 TimeInterval은 1970년 1월 1일 이후의 초 단위 시간입니다. 이를 Date 객체로 변환할 때 값이 음수이거나 미래 날짜(현재 시간 + 1분 이상)면 유효하지 않은 데이터로 판단하고 거부합니다. 또한 서핑 세션 길이가 10시간을 초과하면 명백한 오류로 간주합니다.
isReachable 체크 및 재시도 로직 메시지를 보내기 전에 WCSession.default.isReachable을 확인합니다. false이면 iPhone이 꺼져 있거나 범위 밖에 있다는 의미이므로, 사용자에게 "iPhone을 켜고 가까이 두세요" 안내를 표시합니다. 전송 실패 시 자동 재시도는 구현하지 않았는데, 사용자가 명시적으로 재전송 버튼을 눌러야 하는 것이 데이터 손실을 방지하는 더 안전한 방법이라고 판단했습니다.
배운 점 및 한계
측정된 안정성
* 전송 성공률: 약 95% (테스트 100회 기준)
* 전송 실패 원인: iPhone 백그라운드 상태(3%), 블루투스 범위 초과(2%)
동기식 응답의 장점 replyHandler를 사용하기 전에는 Watch에서 데이터를 보낸 후 iPhone에서 제대로 받았는지 알 수 없었습니다. 사용자는 "보냈는데 iPhone에 안 보여요"라고 불만을 제기했고, 디버깅이 어려웠습니다. 동기식 응답을 구현한 후 이런 문제가 사라졌습니다.
네트워크 불안정성 대응 부족 현재는 전송 실패 시 사용자가 수동으로 재시도해야 합니다. 그러나 서핑을 마친 직후 바다에서 나올 때는 Watch와 iPhone이 멀리 떨어져 있을 수 있습니다. 이 경우 데이터를 Watch에 임시 저장해두고, 다음에 연결되면 자동으로 재전송하는 큐 시스템이 필요합니다.
TimeInterval의 정밀도 문제 TimeInterval은 Double 타입이라 부동소수점 오차가 있습니다. 서핑 시간을 초 단위로 표시할 때는 문제없지만, 밀리초 단위가 필요한 운동 분석에는 부적합합니다. 향후 고정밀 시간 측정이 필요하면 DispatchTime이나 mach_absolute_time을 고려해야 합니다.
개선 방향 전송 실패한 데이터를 Watch의 로컬 스토리지에 저장하고, 백그라운드에서 주기적으로 재전송을 시도하는 시스템을 구현하면 사용자 경험이 크게 개선될 것입니다. 또한 iPhone이 오프라인일 때를 대비해 iCloud를 통한 동기화도 고려할 수 있습니다.

6. API 요청 자동 취소
기술적 도전
사용자가 해변 선택 드롭다운에서 여러 해변을 빠르게 클릭하면, 각 클릭마다 API 요청이 발생합니다. 예를 들어 양양 죽도, 양양 인구, 양양 기사문을 1초 안에 연속으로 선택하면 3개의 API 요청이 동시에 날아갑니다. 이 중 처음 두 개는 불필요한 요청이고, 마지막 요청의 결과만 화면에 표시되어야 합니다.
문제는 네트워크 응답 순서가 요청 순서와 다를 수 있다는 것입니다. 양양 기사문 응답이 먼저 도착하고 양양 인구 응답이 나중에 도착하면, 사용자는 양양 기사문을 선택했는데 양양 인구 데이터가 화면에 표시되는 버그를 경험합니다.
해결 접근
flatMapLatest로 이전 요청 자동 취소 RxSwift의 flatMapLatest 오퍼레이터는 새로운 이벤트가 발생하면 이전 작업을 자동으로 취소합니다. 해변 선택 이벤트 스트림에 flatMapLatest를 연결하면, 사용자가 새로운 해변을 선택하는 순간 이전 API 요청의 구독이 dispose되어 응답을 무시합니다.
내부적으로는 DisposeBag을 동적으로 교체하는 방식으로 동작합니다. flatMapLatest는 이전 내부 구독을 dispose하고 새로운 구독을 생성하므로, 네트워크 레이어에서 URLSessionTask.cancel()이 호출됩니다.
debounce로 입력 스로틀링 사용자가 해변을 선택하는 순간마다 API를 호출하는 것은 비효율적입니다. debounce(120ms)를 추가해, 사용자가 선택을 멈추고 120ms 동안 추가 입력이 없을 때만 API를 호출합니다. 이는 사용자가 리스트를 스크롤하며 여러 항목을 지나칠 때 중간 항목들에 대한 요청을 방지합니다.
120ms라는 값은 사용자가 체감할 수 없을 정도로 짧으면서도, 빠른 연속 클릭을 필터링하기에 충분한 시간입니다. 100ms는 너무 짧아 효과가 없었고, 200ms는 반응이 느리다는 느낌을 주었습니다.
스레드 관리 API 호출은 백그라운드 스레드에서 실행되어야 하므로 subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))를 추가했습니다. 응답 처리는 메인 스레드에서 이루어져야 하므로 observe(on: MainScheduler.instance)를 사용합니다. 이 두 스케줄러를 명시하지 않으면 UI가 버벅이거나 "UI 업데이트는 메인 스레드에서" 런타임 경고가 발생합니다.
배운 점 및 한계
측정된 개선
* flatMapLatest 적용 전: 빠른 연속 선택 시 불필요한 API 호출 평균 3.5회
* flatMapLatest 적용 후: 불필요한 API 호출 0회
* debounce 추가 후: 사용자 체감 지연 없이 API 호출 50% 추가 감소
네트워크 취소의 한계 flatMapLatest는 RxSwift 레벨에서 구독을 취소하지만, 이미 전송된 네트워크 패킷은 취소할 수 없습니다. 요청이 서버에 도착해 처리 중이라면 서버 리소스는 이미 소비된 상태입니다. 클라이언트는 응답을 무시할 뿐입니다. 이는 Firebase의 읽기 쿼터를 소비하므로, debounce가 더 근본적인 해결책입니다.
debounce 값의 주관성 120ms는 경험적으로 결정했지만, 사용자마다 선호하는 반응 속도가 다를 수 있습니다. 이상적으로는 사용자 설정으로 제공하거나, A/B 테스트로 최적값을 찾아야 하지만 현재는 구현하지 않았습니다.
메모리 누수 방지 flatMapLatest와 DisposeBag을 잘못 사용하면 메모리 누수가 발생할 수 있습니다. ViewModel이 해제될 때 DisposeBag도 함께 해제되는지 Instruments로 확인했고, 현재는 문제가 없었습니다. 그러나 복잡한 중첩 구독에서는 항상 주의가 필요합니다.
개선 방향 현재는 해변 선택만 flatMapLatest를 적용했지만, 날짜 범위 필터나 정렬 기준 변경 같은 다른 사용자 입력에도 같은 패턴을 적용할 수 있습니다. 공통 유틸리티 함수로 추출하면 코드 중복을 줄이고 일관성을 유지할 수 있습니다.
